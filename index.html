<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive 3D Military Book</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e, #16213e, #0f3460);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
            cursor: grab;
        }
        body.grabbing {
            cursor: grabbing;
        }
        canvas {
            display: block;
        }
        .controls {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #ffffff;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        .controls h3 {
            margin: 0 0 10px 0;
            color: #ffd700;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.5);
        }
        .control-group {
            margin: 10px 0;
        }
        .control-group label {
            display: block;
            margin-bottom: 5px;
            font-size: 12px;
            color: #cccccc;
        }
        .control-group button {
            background: linear-gradient(45deg, #2c5530, #4a7c59);
            color: white;
            border: none;
            padding: 8px 12px;
            margin: 2px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .control-group button:hover {
            background: linear-gradient(45deg, #4a7c59, #2c5530);
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        }
        .info {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: #ffffff;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            font-size: 12px;
        }
        .title {
            position: absolute;
            top: 20px;
            right: 20px;
            color: #ffd700;
            background: rgba(0, 0, 0, 0.8);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 215, 0, 0.3);
            text-align: center;
        }
        .title h1 {
            margin: 0;
            font-size: 18px;
            text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
        }
        .title p {
            margin: 5px 0 0 0;
            font-size: 12px;
            color: #cccccc;
        }
    </style>
</head>
<body>
    <div class="title">
        <h1>PRESTIGIOUS MILITARY PUBLICATION</h1>
        <p>Interactive 3D Mockup</p>
    </div>
    
    <div class="controls">
        <h3>üéõÔ∏è Controls</h3>
        <div class="control-group">
            <label>Book Animation:</label>
            <button onclick="openBook()">Open Book</button>
            <button onclick="closeBook()">Close Book</button>
            <button onclick="flipPage()">Flip Page</button>
        </div>
        <div class="control-group">
            <label>Camera Views:</label>
            <button onclick="setCameraView('front')">Front View</button>
            <button onclick="setCameraView('angle')">Angle View</button>
            <button onclick="setCameraView('top')">Top View</button>
        </div>
        <div class="control-group">
            <label>Effects:</label>
            <button onclick="toggleRotation()">Auto Rotate</button>
            <button onclick="resetPosition()">Reset</button>
        </div>
    </div>

    <div class="info">
        <strong>Instructions:</strong><br>
        ‚Ä¢ Drag to rotate the book<br>
        ‚Ä¢ Scroll to zoom in/out<br>
        ‚Ä¢ Use controls for animations<br>
        ‚Ä¢ Replace image URLs with your covers
    </div>

    <script>
        let scene, camera, renderer, book, frontCover, backCover, spine, pages;
        let isMouseDown = false;
        let mouseX = 0, mouseY = 0;
        let targetRotationX = 0, targetRotationY = 0;
        let currentRotationX = 0, currentRotationY = 0;
        let autoRotate = false;
        let bookGroup;
        let isBookOpen = false;
        let animationId;

        // Initialize the scene
        function init() {
            // Scene
            scene = new THREE.Scene();
            
            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 2, 5);
            camera.lookAt(0, 0, 0);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setClearColor(0x000000, 0);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.body.appendChild(renderer.domElement);

            // Lighting setup for premium look
            const ambientLight = new THREE.AmbientLight(0x404040, 0.6);
            scene.add(ambientLight);

            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 5);
            directionalLight.castShadow = true;
            directionalLight.shadow.mapSize.width = 2048;
            directionalLight.shadow.mapSize.height = 2048;
            scene.add(directionalLight);

            const spotLight = new THREE.SpotLight(0xffd700, 0.8);
            spotLight.position.set(-3, 8, 3);
            spotLight.castShadow = true;
            scene.add(spotLight);

            // Create book group
            bookGroup = new THREE.Group();
            scene.add(bookGroup);

            // Create book
            createBook();

            // Add event listeners
            addEventListeners();

            // Start animation loop
            animate();
        }

        function createBook() {
            const bookWidth = 4.0;  // 16:9 landscape - wider
            const bookHeight = 2.25; // 16:9 landscape - shorter
            const bookDepth = 0.3;

            // Book materials with local cover images
            const frontCoverMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFFFFF,
                shininess: 30,
                map: loadImageTexture('./static/images/FRONT COVER PAGE.png')
            });

            const backCoverMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFFFFF,
                shininess: 30,
                map: loadImageTexture('./static/images/BACK COVER PAGE.png')
            });

            const spineMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x320F02,
                shininess: 50
            });

            const pagesMaterial = new THREE.MeshPhongMaterial({ 
                color: 0xFFFFF0,
                shininess: 10
            });

            // Front cover
            const frontGeometry = new THREE.BoxGeometry(bookWidth, bookHeight, 0.05);
            frontCover = new THREE.Mesh(frontGeometry, frontCoverMaterial);
            frontCover.position.set(0, 0, bookDepth/2 + 0.025);
            frontCover.castShadow = true;
            frontCover.receiveShadow = true;
            bookGroup.add(frontCover);

            // Back cover
            const backGeometry = new THREE.BoxGeometry(bookWidth, bookHeight, 0.05);
            backCover = new THREE.Mesh(backGeometry, backCoverMaterial);
            backCover.position.set(0, 0, -bookDepth/2 - 0.025);
            backCover.castShadow = true;
            backCover.receiveShadow = true;
            bookGroup.add(backCover);

            // Spine
            const spineGeometry = new THREE.BoxGeometry(0.05, bookHeight, bookDepth);
            spine = new THREE.Mesh(spineGeometry, spineMaterial);
            spine.position.set(-bookWidth/2 - 0.025, 0, 0);
            spine.castShadow = true;
            spine.receiveShadow = true;
            bookGroup.add(spine);

            // Pages
            const pagesGeometry = new THREE.BoxGeometry(bookWidth * 0.95, bookHeight * 0.95, bookDepth * 0.8);
            pages = new THREE.Mesh(pagesGeometry, pagesMaterial);
            pages.position.set(0.025, 0, 0);
            pages.castShadow = true;
            pages.receiveShadow = true;
            bookGroup.add(pages);

            // Add subtle glow effect
            const glowGeometry = new THREE.BoxGeometry(bookWidth * 1.1, bookHeight * 1.1, bookDepth * 1.1);
            const glowMaterial = new THREE.MeshBasicMaterial({
                color: 0xffd700,
                transparent: true,
                opacity: 0.1,
                side: THREE.BackSide
            });
            const glow = new THREE.Mesh(glowGeometry, glowMaterial);
            bookGroup.add(glow);

            // Ground plane for shadows
            const groundGeometry = new THREE.PlaneGeometry(20, 20);
            const groundMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x333333, 
                transparent: true, 
                opacity: 0.3 
            });
            const ground = new THREE.Mesh(groundGeometry, groundMaterial);
            ground.rotation.x = -Math.PI / 2;
            ground.position.y = -2;
            ground.receiveShadow = true;
            scene.add(ground);
        }

        function loadImageTexture(imageUrl) {
            const loader = new THREE.TextureLoader();
            const texture = loader.load(
                imageUrl,
                function(texture) {
                    // Image loaded successfully
                    texture.wrapS = THREE.ClampToEdgeWrapping;
                    texture.wrapT = THREE.ClampToEdgeWrapping;
                    texture.minFilter = THREE.LinearFilter;
                    texture.magFilter = THREE.LinearFilter;
                },
                function(progress) {
                    // Loading progress
                    console.log('Loading progress: ' + (progress.loaded / progress.total * 100) + '%');
                },
                function(error) {
                    // Error loading image
                    console.error('Error loading texture:', error);
                }
            );
            return texture;
        }

        function addEventListeners() {
            // Mouse events
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('mouseup', onMouseUp);
            document.addEventListener('wheel', onWheel);
            
            // Touch events for mobile
            document.addEventListener('touchstart', onTouchStart);
            document.addEventListener('touchmove', onTouchMove);
            document.addEventListener('touchend', onTouchEnd);
            
            // Window resize
            window.addEventListener('resize', onWindowResize);
        }

        function onMouseDown(event) {
            isMouseDown = true;
            mouseX = event.clientX;
            mouseY = event.clientY;
            document.body.classList.add('grabbing');
        }

        function onMouseMove(event) {
            if (!isMouseDown) return;
            
            const deltaX = event.clientX - mouseX;
            const deltaY = event.clientY - mouseY;
            
            targetRotationY += deltaX * 0.01;
            targetRotationX += deltaY * 0.01;
            
            // Limit vertical rotation
            targetRotationX = Math.max(-Math.PI/3, Math.min(Math.PI/3, targetRotationX));
            
            mouseX = event.clientX;
            mouseY = event.clientY;
        }

        function onMouseUp() {
            isMouseDown = false;
            document.body.classList.remove('grabbing');
        }

        function onWheel(event) {
            camera.position.z += event.deltaY * 0.01;
            camera.position.z = Math.max(2, Math.min(10, camera.position.z));
        }

        function onTouchStart(event) {
            if (event.touches.length === 1) {
                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
                isMouseDown = true;
            }
        }

        function onTouchMove(event) {
            if (event.touches.length === 1 && isMouseDown) {
                const deltaX = event.touches[0].clientX - mouseX;
                const deltaY = event.touches[0].clientY - mouseY;
                
                targetRotationY += deltaX * 0.01;
                targetRotationX += deltaY * 0.01;
                
                targetRotationX = Math.max(-Math.PI/3, Math.min(Math.PI/3, targetRotationX));
                
                mouseX = event.touches[0].clientX;
                mouseY = event.touches[0].clientY;
            }
        }

        function onTouchEnd() {
            isMouseDown = false;
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // Animation functions
        function openBook() {
            if (isBookOpen) return;
            isBookOpen = true;
            
            const duration = 2000; // 2 seconds
            const startTime = Date.now();
            const startRotation = frontCover.rotation.y;
            const targetRotation = -Math.PI * 0.7;
            
            function animateOpen() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easing = 1 - Math.pow(1 - progress, 3); // Ease out cubic
                
                frontCover.rotation.y = startRotation + (targetRotation - startRotation) * easing;
                
                if (progress < 1) {
                    requestAnimationFrame(animateOpen);
                }
            }
            
            animateOpen();
        }

        function closeBook() {
            if (!isBookOpen) return;
            isBookOpen = false;
            
            const duration = 1500;
            const startTime = Date.now();
            const startRotation = frontCover.rotation.y;
            const targetRotation = 0;
            
            function animateClose() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easing = 1 - Math.pow(1 - progress, 2); // Ease out quad
                
                frontCover.rotation.y = startRotation + (targetRotation - startRotation) * easing;
                
                if (progress < 1) {
                    requestAnimationFrame(animateClose);
                }
            }
            
            animateClose();
        }

        function flipPage() {
            // Create a page flip animation effect
            const page = pages.clone();
            page.material = new THREE.MeshPhongMaterial({ 
                color: 0xFFFFF0, 
                transparent: true, 
                opacity: 0.8 
            });
            bookGroup.add(page);
            
            const duration = 1000;
            const startTime = Date.now();
            
            function animateFlip() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const rotation = Math.PI * progress;
                
                page.rotation.y = rotation;
                page.material.opacity = 0.8 * (1 - progress * 0.5);
                
                if (progress < 1) {
                    requestAnimationFrame(animateFlip);
                } else {
                    bookGroup.remove(page);
                }
            }
            
            animateFlip();
        }

        function setCameraView(view) {
            const duration = 1500;
            const startTime = Date.now();
            const startPosition = camera.position.clone();
            let targetPosition;
            
            switch(view) {
                case 'front':
                    targetPosition = new THREE.Vector3(0, 0, 5);
                    break;
                case 'angle':
                    targetPosition = new THREE.Vector3(3, 2, 4);
                    break;
                case 'top':
                    targetPosition = new THREE.Vector3(0, 6, 2);
                    break;
            }
            
            function animateCamera() {
                const elapsed = Date.now() - startTime;
                const progress = Math.min(elapsed / duration, 1);
                const easing = 1 - Math.pow(1 - progress, 3);
                
                camera.position.lerpVectors(startPosition, targetPosition, easing);
                camera.lookAt(0, 0, 0);
                
                if (progress < 1) {
                    requestAnimationFrame(animateCamera);
                }
            }
            
            animateCamera();
        }

        function toggleRotation() {
            autoRotate = !autoRotate;
        }

        function resetPosition() {
            targetRotationX = 0;
            targetRotationY = 0;
            camera.position.set(0, 2, 6);
            camera.lookAt(0, 0, 0);
            closeBook();
        }

        function animate() {
            requestAnimationFrame(animate);
            
            // Smooth rotation interpolation
            currentRotationX += (targetRotationX - currentRotationX) * 0.05;
            currentRotationY += (targetRotationY - currentRotationY) * 0.05;
            
            // Auto rotation
            if (autoRotate) {
                targetRotationY += 0.005;
            }
            
            // Apply rotation to book
            bookGroup.rotation.x = currentRotationX;
            bookGroup.rotation.y = currentRotationY;
            
            // Floating animation
            bookGroup.position.y = Math.sin(Date.now() * 0.001) * 0.1;
            
            renderer.render(scene, camera);
        }

        // Initialize when page loads
        window.addEventListener('load', init);
    </script>
</body>
</html>